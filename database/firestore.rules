rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check if the user is the owner
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Check if user is a member of a group with specific status
    function isGroupMember(groupId) {
      return isAuthenticated() &&
             exists(/databases/$(database)/documents/groupMembers/$(groupId + '_' + request.auth.uid)) &&
             get(/databases/$(database)/documents/groupMembers/$(groupId + '_' + request.auth.uid)).data.status == 'active';
    }
    
    // Get user's role in a group
    function getGroupRole(groupId) {
      return get(/databases/$(database)/documents/groupMembers/$(groupId + '_' + request.auth.uid)).data.role;
    }
    
    // Check if user has specific role in group
    function hasGroupRole(groupId, role) {
      return isGroupMember(groupId) && getGroupRole(groupId) == role;
    }
    
    // Check if user is owner or admin of group
    function isGroupAdmin(groupId) {
      return isGroupMember(groupId) && 
             (getGroupRole(groupId) == 'owner' || getGroupRole(groupId) == 'admin');
    }
    
    // Check if user is group owner
    function isGroupOwner(groupId) {
      return hasGroupRole(groupId, 'owner');
    }
    
    // Check if user can add expenses to group
    function canAddGroupExpenses(groupId) {
      return isGroupMember(groupId) && 
             get(/databases/$(database)/documents/groupMembers/$(groupId + '_' + request.auth.uid)).data.permissions.canAddExpenses == true;
    }
    
    // Check if user can approve expenses in group
    function canApproveExpenses(groupId) {
      return isGroupMember(groupId) && 
             get(/databases/$(database)/documents/groupMembers/$(groupId + '_' + request.auth.uid)).data.permissions.canApproveExpenses == true;
    }
    
    // ============================================
    // EXPENSES COLLECTION (Enhanced for Groups)
    // ============================================
    
    match /expenses/{expenseId} {
      // List expenses (for queries) - allow authenticated users
      // The where clause in the query will filter by userId or groupId
      allow list: if isAuthenticated();
      
      // Get specific expense
      allow get: if isAuthenticated() && (
        // Personal expense: owner can read
        (resource.data.expenseType == 'personal' && resource.data.userId == request.auth.uid) ||
        // Group expense: group member can read
        (resource.data.expenseType == 'group' && isGroupMember(resource.data.groupId))
      );
      
      // Create rules
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.keys().hasAll(['vendor', 'amount', 'date', 'category', 'userId', 'expenseType']) &&
        request.resource.data.amount is number &&
        request.resource.data.amount > 0 &&
        // Validate expense type
        (request.resource.data.expenseType in ['personal', 'group']) &&
        // If personal expense, no groupId required
        (
          (request.resource.data.expenseType == 'personal' && 
           (!request.resource.data.keys().hasAny(['groupId']) || request.resource.data.groupId == null))
          ||
          // If group expense, must be member with permission
          (request.resource.data.expenseType == 'group' && 
           request.resource.data.keys().hasAll(['groupId']) &&
           request.resource.data.groupId is string &&
           canAddGroupExpenses(request.resource.data.groupId))
        );
      
      // Update rules
      allow update: if isAuthenticated() && (
        // Personal expense: owner can update
        (resource.data.expenseType == 'personal' && 
         resource.data.userId == request.auth.uid &&
         request.resource.data.userId == request.auth.uid &&
         request.resource.data.expenseType == 'personal') ||
        // Group expense: creator or admin can update
        (resource.data.expenseType == 'group' &&
         request.resource.data.expenseType == 'group' &&
         request.resource.data.groupId == resource.data.groupId && // Can't change group
         (
           // Owner can edit their own expense
           (resource.data.userId == request.auth.uid && 
            get(/databases/$(database)/documents/groupMembers/$(resource.data.groupId + '_' + request.auth.uid)).data.permissions.canEditOwnExpenses == true) ||
           // Admin can edit any expense
           (get(/databases/$(database)/documents/groupMembers/$(resource.data.groupId + '_' + request.auth.uid)).data.permissions.canEditAllExpenses == true)
         )) ||
        // Approval action: only approvers
        (resource.data.expenseType == 'group' &&
         request.resource.data.keys().hasOnly(['groupMetadata']) &&
         request.resource.data.groupMetadata.keys().hasAny(['approvalStatus', 'approvedBy', 'approvedAt']) &&
         canApproveExpenses(resource.data.groupId))
      );
      
      // Delete rules
      allow delete: if isAuthenticated() && (
        // Personal expense: owner can delete
        (resource.data.expenseType == 'personal' && resource.data.userId == request.auth.uid) ||
        // Group expense: creator or admin with permission can delete
        (resource.data.expenseType == 'group' && (
          (resource.data.userId == request.auth.uid) ||
          (get(/databases/$(database)/documents/groupMembers/$(resource.data.groupId + '_' + request.auth.uid)).data.permissions.canDeleteExpenses == true)
        ))
      );
    }
    
    // ============================================
    // GROUPS COLLECTION
    // ============================================
    
    match /groups/{groupId} {
      // Anyone can read groups they're a member of
      allow read: if isAuthenticated() && isGroupMember(groupId);
      
      // Any authenticated user can create a group
      allow create: if isAuthenticated() &&
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.keys().hasAll(['name', 'createdBy', 'createdAt', 'status', 'settings', 'stats']) &&
        request.resource.data.status == 'active' &&
        request.resource.data.stats.memberCount == 1;
      
      // Only owner can update group settings
      allow update: if isAuthenticated() && (
        // Owner can update anything
        (isGroupOwner(groupId) && request.resource.data.createdBy == resource.data.createdBy) ||
        // Admin can update non-critical fields
        (isGroupAdmin(groupId) && 
         !request.resource.data.diff(resource.data).affectedKeys().hasAny(['createdBy', 'status', 'settings.requireApproval', 'settings.allowMemberInvites']))
      );
      
      // Only owner can delete/archive groups
      allow delete: if isAuthenticated() && isGroupOwner(groupId);
    }
    
    // ============================================
    // GROUP MEMBERS COLLECTION
    // ============================================
    
    match /groupMembers/{membershipId} {
      // Allow authenticated users to list memberships (needed for queries)
      // The where clause will filter to their own memberships
      allow list: if isAuthenticated();
      
      // Users can get specific membership if they're in that group
      allow get: if isAuthenticated() && 
        isGroupMember(resource.data.groupId);
      
      // System creates membership when group is created or invitation accepted
      // Must be done via server-side (admin SDK) for security
      allow create: if false; // Only server-side
      
      // Only owner/admin can update member roles
      allow update: if isAuthenticated() && (
        // Owner can update anyone (except can't change own status)
        (isGroupOwner(resource.data.groupId) && 
         resource.data.userId != request.auth.uid) ||
        // Admin can update members (not owner or other admins)
        (isGroupAdmin(resource.data.groupId) && 
         resource.data.role != 'owner' &&
         resource.data.role != 'admin' &&
         request.resource.data.role != 'owner') ||
        // Member can update their own lastActivityAt
        (resource.data.userId == request.auth.uid &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastActivityAt']))
      );
      
      // Members can leave (soft delete by changing status)
      // Admins can remove members
      allow update: if isAuthenticated() && (
        // Member leaving voluntarily
        (resource.data.userId == request.auth.uid &&
         request.resource.data.status == 'left' &&
         resource.data.role != 'owner') || // Owner can't leave
        // Admin removing a member
        (isGroupAdmin(resource.data.groupId) &&
         request.resource.data.status == 'removed' &&
         resource.data.role != 'owner') // Can't remove owner
      );
      
      // Only server-side can hard delete
      allow delete: if false;
    }
    
    // ============================================
    // GROUP INVITATIONS COLLECTION
    // ============================================
    
    match /groupInvitations/{invitationId} {
      // Only invitee or group members can read
      allow read: if isAuthenticated() && (
        resource.data.invitedEmail == request.auth.token.email ||
        isGroupMember(resource.data.groupId)
      );
      
      // Only server-side can create (to generate secure token)
      allow create: if false;
      
      // Invitee can accept/reject
      // Inviter can cancel
      allow update: if isAuthenticated() && (
        // Invitee accepting/rejecting
        (resource.data.invitedEmail == request.auth.token.email &&
         request.resource.data.status in ['accepted', 'rejected'] &&
         resource.data.status == 'pending') ||
        // Admin canceling
        (isGroupAdmin(resource.data.groupId) &&
         request.resource.data.status == 'cancelled')
      );
      
      // Only server-side can delete
      allow delete: if false;
    }
    
    // ============================================
    // GROUP ACTIVITIES COLLECTION (Audit Log)
    // ============================================
    
    match /groupActivities/{activityId} {
      // Members can read activity log
      allow read: if isAuthenticated() && 
        isGroupMember(resource.data.groupId);
      
      // Only server-side can write (for security & consistency)
      allow create, update, delete: if false;
    }
    
    // ============================================
    // USER PROFILES COLLECTION
    // ============================================
    
    match /users/{userId} {
      allow read: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if false; // Never allow deletion
    }
    
    // ============================================
    // PASSKEYS COLLECTION
    // ============================================
    
    match /passkeys/{passkeyId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // ============================================
    // CHALLENGES COLLECTION (for passkey auth)
    // ============================================
    
    match /challenges/{challengeId} {
      allow read, write: if isAuthenticated();
    }
    
    // ============================================
    // ANALYTICS COLLECTION (server-side only)
    // ============================================
    
    match /analytics/{analyticsId} {
      allow read: if false; // Only server-side reads
      allow write: if false; // Only server-side writes
    }
    
    // ============================================
    // CONVERSATIONS COLLECTION (NEW)
    // ============================================
    
    match /conversations/{conversationId} {
      // Allow list queries for user's own conversations
      allow list: if isAuthenticated();
      
      // Users can get their own conversations
      allow get, delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      
      // Any authenticated user can create a conversation
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.keys().hasAll(['userId', 'title', 'createdAt', 'updatedAt', 'status', 'messageCount', 'lastMessagePreview', 'metadata']) &&
        request.resource.data.status == 'active' &&
        request.resource.data.messageCount >= 0;
      
      // Users can update their own conversations
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        request.resource.data.userId == request.auth.uid;
      
      // Messages subcollection
      match /messages/{messageId} {
        // Allow list queries for messages
        allow list: if isAuthenticated();
        
        // Users can read messages from their own conversations
        allow get, create: if isAuthenticated() && 
          get(/databases/$(database)/documents/conversations/$(conversationId)).data.userId == request.auth.uid;
        
        // Users can update/delete messages in their own conversations
        allow delete, update: if isAuthenticated() && 
          get(/databases/$(database)/documents/conversations/$(conversationId)).data.userId == request.auth.uid;
      }
    }
    
    // ============================================
    // BUDGETS COLLECTION (NEW)
    // ============================================
    
    // Personal Budgets
    match /budgets_personal/{budgetId} {
      // Allow list queries for user's own budgets
      allow list: if isAuthenticated();
      
      // Users can read their own budgets
      allow get: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      
      // Users can create their own budgets
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.keys().hasAll(['userId', 'category', 'monthlyLimit', 'period', 'settings']) &&
        request.resource.data.monthlyLimit is number &&
        request.resource.data.monthlyLimit > 0 &&
        request.resource.data.period.month >= 1 &&
        request.resource.data.period.month <= 12 &&
        request.resource.data.period.year >= 2020;
      
      // Users can update their own budgets
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        request.resource.data.userId == request.auth.uid;
      
      // Users can delete their own budgets
      allow delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Group Budgets
    match /budgets_group/{budgetId} {
      // Allow list queries only if filtering by a group where user is member
      // Note: Firestore requires that list rules match the query filters
      allow list: if isAuthenticated();
      
      // Group members can read group budgets
      allow get: if isAuthenticated() && 
        resource.data.groupId is string &&
        isGroupMember(resource.data.groupId);
      
      // Only admin or owner can create group budgets
      allow create: if isAuthenticated() && 
        isGroupAdmin(request.resource.data.groupId) &&
        request.resource.data.keys().hasAll(['groupId', 'category', 'monthlyLimit', 'period', 'setBy', 'setByRole', 'settings']) &&
        request.resource.data.setBy == request.auth.uid &&
        request.resource.data.monthlyLimit is number &&
        request.resource.data.monthlyLimit > 0;
      
      // Only admin or owner can update group budgets
      allow update: if isAuthenticated() && 
        isGroupAdmin(resource.data.groupId) &&
        resource.data.groupId == request.resource.data.groupId; // Can't change group
      
      // Only admin or owner can delete group budgets
      allow delete: if isAuthenticated() && 
        isGroupAdmin(resource.data.groupId);
    }
    
    // Budget Usage Cache (calculated data)
    match /budget_usage_cache/{cacheId} {
      // Users can read their own cache or group cache they're member of
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        (resource.data.keys().hasAny(['groupId']) && isGroupMember(resource.data.groupId))
      );
      
      // Only server-side can write (for consistency)
      allow create, update, delete: if false;
    }
    
    // Budget Alerts
    match /budget_alerts/{alertId} {
      // Users can read their own alerts
      allow read: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      
      // Users can update their own alerts (mark as read/dismissed)
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        request.resource.data.userId == request.auth.uid &&
        // Can only update readAt and dismissedAt
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['readAt', 'dismissedAt']);
      
      // Only server-side can create/delete alerts
      allow create, delete: if false;
    }
    
    // ============================================
    // NOTIFICATIONS SYSTEM (NEW)
    // ============================================
    
    // Notifications Collection
    match /notifications/{notificationId} {
      // Users can list their own notifications
      allow list: if isAuthenticated();
      
      // Users can read their own notifications
      allow get: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      
      // Only server-side can create notifications (for security & consistency)
      allow create: if false;
      
      // Users can update their own notifications (mark as read, update metadata)
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        request.resource.data.userId == request.auth.uid &&
        // Can only update read, readAt, delivered, deliveredAt
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'readAt', 'delivered', 'deliveredAt']);
      
      // Users can delete their own notifications
      allow delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // User Notification Settings (Global)
    match /userNotificationSettings/{userId} {
      // Users can read their own settings
      allow read: if isAuthenticated() && userId == request.auth.uid;
      
      // Users can create their own settings
      allow create: if isAuthenticated() && 
        userId == request.auth.uid &&
        request.resource.data.userId == request.auth.uid;
      
      // Users can update their own settings
      allow update: if isAuthenticated() && 
        userId == request.auth.uid &&
        request.resource.data.userId == request.auth.uid;
      
      // Users can delete their own settings
      allow delete: if isAuthenticated() && userId == request.auth.uid;
    }
    
    // Notification Preferences (Per-Type)
    match /users/{userId}/notificationPreferences/{preferencesId} {
      // Users can read their own preferences
      allow read: if isAuthenticated() && userId == request.auth.uid;
      
      // Users can create their own preferences
      allow create: if isAuthenticated() && userId == request.auth.uid;
      
      // Users can update their own preferences
      allow update: if isAuthenticated() && userId == request.auth.uid;
      
      // Users can delete their own preferences
      allow delete: if isAuthenticated() && userId == request.auth.uid;
    }
    
    // Alternative: If using root collection for preferences
    match /notificationPreferences/{userId} {
      // Users can read their own preferences
      allow read: if isAuthenticated() && userId == request.auth.uid;
      
      // Users can create their own preferences
      allow create: if isAuthenticated() && 
        userId == request.auth.uid &&
        request.resource.data.userId == request.auth.uid;
      
      // Users can update their own preferences
      allow update: if isAuthenticated() && 
        userId == request.auth.uid;
      
      // Users can delete their own preferences
      allow delete: if isAuthenticated() && userId == request.auth.uid;
    }
    
    // Push Subscriptions
    match /pushSubscriptions/{subscriptionId} {
      // Users can list their own subscriptions
      allow list: if isAuthenticated();
      
      // Users can read their own subscriptions
      allow get: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      
      // Users can create their own push subscriptions
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid;
      
      // Users can update their own subscriptions
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        request.resource.data.userId == request.auth.uid;
      
      // Users can delete their own subscriptions
      allow delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Budget Notification Trackers (NEW)
    match /budgetNotificationTrackers/{trackerId} {
      // Users can read their own trackers
      allow read: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      
      // Only server-side can create/update/delete trackers (for consistency)
      allow create, update, delete: if false;
    }
    
    // Notification Groups (for grouping logic)
    match /notificationGroups/{groupKey} {
      // Users can read their own notification groups
      allow read: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      
      // Only server-side can create/update/delete notification groups
      allow create, update, delete: if false;
    }
    
    // ============================================
    // INCOME & SAVINGS SYSTEM (NEW)
    // ============================================
    
    // Personal Income Sources
    match /income_sources_personal/{incomeId} {
      // Users can list their own income sources
      allow list: if isAuthenticated();
      
      // Users can read their own income sources
      allow get: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      
      // Users can create their own income sources
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.keys().hasAll(['userId', 'name', 'category', 'amount', 'frequency', 'isRecurring', 'isActive', 'currency', 'taxable']) &&
        request.resource.data.amount is number &&
        request.resource.data.amount > 0;
      
      // Users can update their own income sources
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        request.resource.data.userId == request.auth.uid;
      
      // Users can delete their own income sources
      allow delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Group Income Sources
    match /income_sources_group/{incomeId} {
      // Allow list queries for group members
      allow list: if isAuthenticated();
      
      // Group members can read group income sources
      allow get: if isAuthenticated() && 
        resource.data.groupId is string &&
        isGroupMember(resource.data.groupId);
      
      // Only admin or owner can create group income sources
      allow create: if isAuthenticated() && 
        isGroupAdmin(request.resource.data.groupId) &&
        request.resource.data.keys().hasAll(['groupId', 'addedBy', 'name', 'category', 'amount', 'frequency', 'isRecurring', 'isActive', 'currency', 'taxable']) &&
        request.resource.data.addedBy == request.auth.uid &&
        request.resource.data.amount is number &&
        request.resource.data.amount > 0;
      
      // Only admin or owner can update group income sources
      allow update: if isAuthenticated() && 
        isGroupAdmin(resource.data.groupId) &&
        resource.data.groupId == request.resource.data.groupId;
      
      // Only admin or owner can delete group income sources
      allow delete: if isAuthenticated() && 
        isGroupAdmin(resource.data.groupId);
    }
    
    // Monthly Income Records
    match /monthly_income_records/{recordId} {
      // Users can read their own records or group records they're member of
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        (resource.data.keys().hasAny(['groupId']) && isGroupMember(resource.data.groupId))
      );
      
      // Only server-side can create/update records (for consistency)
      allow create, update, delete: if false;
    }
    
    // Monthly Setup Status
    match /monthly_setup_status/{statusId} {
      // Users can read their own status or group status they're member of
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        (resource.data.keys().hasAny(['groupId']) && isGroupMember(resource.data.groupId))
      );
      
      // Users can update their own status or admins can update group status
      allow update: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        (resource.data.keys().hasAny(['groupId']) && isGroupAdmin(resource.data.groupId))
      );
      
      // Only server-side can create/delete status records
      allow create, delete: if false;
    }
    
    // Budget Allocation History
    match /budget_allocation_history/{historyId} {
      // Users can read their own history or group history they're member of
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        (resource.data.keys().hasAny(['groupId']) && isGroupMember(resource.data.groupId))
      );
      
      // Only server-side can write history (for consistency)
      allow create, update, delete: if false;
    }
    
    // Personal Savings Goals
    match /savings_goals_personal/{goalId} {
      // Users can list their own savings goals
      allow list: if isAuthenticated();
      
      // Users can read their own savings goals
      allow get: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      
      // Users can create their own savings goals
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.keys().hasAll(['userId', 'name', 'category', 'targetAmount', 'currentAmount', 'monthlyContribution', 'status', 'isActive', 'priority', 'currency']) &&
        request.resource.data.targetAmount is number &&
        request.resource.data.targetAmount > 0 &&
        request.resource.data.currentAmount is number &&
        request.resource.data.currentAmount >= 0 &&
        request.resource.data.monthlyContribution is number &&
        request.resource.data.monthlyContribution >= 0;
      
      // Users can update their own savings goals
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        request.resource.data.userId == request.auth.uid;
      
      // Users can delete their own savings goals
      allow delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Group Savings Goals
    match /savings_goals_group/{goalId} {
      // Allow list queries for group members
      allow list: if isAuthenticated();
      
      // Group members can read group savings goals
      allow get: if isAuthenticated() && 
        resource.data.groupId is string &&
        isGroupMember(resource.data.groupId);
      
      // Only admin or owner can create group savings goals
      allow create: if isAuthenticated() && 
        isGroupAdmin(request.resource.data.groupId) &&
        request.resource.data.keys().hasAll(['groupId', 'createdBy', 'name', 'category', 'targetAmount', 'currentAmount', 'monthlyContribution', 'status', 'isActive', 'priority', 'contributionType', 'currency']) &&
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.targetAmount is number &&
        request.resource.data.targetAmount > 0 &&
        request.resource.data.currentAmount is number &&
        request.resource.data.currentAmount >= 0 &&
        request.resource.data.monthlyContribution is number &&
        request.resource.data.monthlyContribution >= 0;
      
      // Only admin or owner can update group savings goals
      allow update: if isAuthenticated() && 
        isGroupAdmin(resource.data.groupId) &&
        resource.data.groupId == request.resource.data.groupId;
      
      // Only admin or owner can delete group savings goals
      allow delete: if isAuthenticated() && 
        isGroupAdmin(resource.data.groupId);
    }
    
    // Savings Contributions
    match /savings_contributions/{contributionId} {
      // Users can read their own contributions or group contributions they're member of
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        (resource.data.keys().hasAny(['groupId']) && isGroupMember(resource.data.groupId))
      );
      
      // Users can create their own contributions or group members can contribute to group goals
      allow create: if isAuthenticated() && (
        (request.resource.data.keys().hasAny(['userId']) && 
         request.resource.data.userId == request.auth.uid) ||
        (request.resource.data.keys().hasAny(['groupId']) && 
         isGroupMember(request.resource.data.groupId))
      );
      
      // Only server-side can update/delete contributions (for consistency)
      allow update, delete: if false;
    }
    
    // Monthly Savings Summary
    match /monthly_savings_summary/{summaryId} {
      // Users can read their own summaries or group summaries they're member of
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        (resource.data.keys().hasAny(['groupId']) && isGroupMember(resource.data.groupId))
      );
      
      // Only server-side can write summaries (for consistency)
      allow create, update, delete: if false;
    }
    
    // ============================================
    // DENY ALL OTHER ACCESS
    // ============================================
    
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
// comment
// comment
